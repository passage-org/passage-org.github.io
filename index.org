#+MACRO: PASSAGE PASSAGE
#+MACRO: GITHUB @@html:<i class="fab fa-github" aria-hidden="true"></i>@@
#+MACRO: GOOGLE @@html:<i class="fab fa-google" aria-hidden="true"></i>@@

#+TITLE: {{{PASSAGE}}}
#+DATE: [2025-01-27 Lun]
#+AUTHOR: chat-wane
#+EMAIL: grumpy dot chat dot wane at gmail dot com

#+HTML_DOCTYPE: html5
#+HTML_XML_DECL: none # this removes <?xml …> that prevents vite from serving

#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: prop:t
#+OPTIONS: html-postamble:nil # removes the footer

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/code.css" />
#+HTML_HEAD: <script src="js/network.js" type="text/javascript"></script>
#+HTML_HEAD: <script src="js/main.js" type="text/javascript"></script>
#+HTML_HEAD: <link rel="stylesheet" href="./node_modules/@fortawesome/fontawesome-free/css/all.min.css" />


#+BEGIN_CENTER
*Ensuring Completeness and Responsiveness of Public SPARQL Endpoints*

*with SPARQL Continuation Queries.*

/This website is _under construction_. Please be patient…/
#+END_CENTER



* About

{{{PASSAGE}}} constitutes an effort towards the adoption of SPARQL
query engines that provide complete and correct results! despite their
timeout threshold on query execution time that enforce fair use
policies…


** Try it live!

*** TODO unavailable for now: trial expired.

We pushed a live demonstration on [[https://live-demo-4455226726.europe-west2.run.app/][{{{GOOGLE}}} Google Cloud]].

#+BEGIN_right-comment
For the first run, the service might
take time to wake  up from idle mode;
so please be patient…
#+END_right-comment

It serves a [[https://dsg.uwaterloo.ca/watdiv/][WatDiv10M dataset]] ingested using the standard [[https://blazegraph.com/][Blazegraph]]
import procedure. We [[https://github.com/passage-org/passage-comunica][added an actor]] to the smart client [[https://comunica.dev/][Comunica]] that
divides query executions between the remote {{{PASSAGE}}} endpoint and
the local web client Comunica.

** How does it work?

On public SPARQL endpoints, a SPARQL query cannot run for more than a
predefined amount of time. When the query execution time reach this
threshold, the query execution is stopped. The results are partial and
a SPARQL continuation query is returned to provide the missing
results.

*** TODO provide a series of SPARQL execution as example.
*** TODO provide an environment to display SPARQL queries.



* Contribute

The code base is available on the [[https://github.com/orgs/passage-org/repositories][{{{GITHUB}}} GitHub platform]]. Feel
free to post issues, or to ask questions there. The reminder of this
section provides details about possible contributions that would be
greatly appreciated.

** Support for Backends

To improve adoption, one major aspect of continuation queries concerns
the support for databases such as [[https://blazegraph.com/][Blazegraph]], [[https://jena.apache.org/][Apache Jena]], or [[https://rdf4j.org/][RDF4J]].

*** Blazegraph

With our first release, we focused on [[https://blazegraph.com/][Blazegraph]]. Despite its
terminated support, the *augmented* balanced trees representing the
triple/quad data store allows {{{PASSAGE}}} to efficiently skip large
part of triple/quad patterns, making simple subqueries with =OFFSET=
clauses executable.

#+BEGIN_SRC sparql :url https://query.wikidata.org/sparql :format text/csv :cache yes :synch no :exports code
  SELECT * WHERE {         # A SELECT query or sub-query
    BIND (rdf:type AS ?p)  # Var(s) assignment(s)
    ?s ?p ?o               # One triple/quad pattern only
  } OFFSET 18000000        # May need to skip a lot of elements
#+END_SRC

On such a query, Blazegraph uses an index where =?p= is bounded first
=POS=. Thus, retrieving all =?o= and =?s= for such a predicate remains
efficient. The results are produced in a deterministic order.  The
=OFFSET= states that the first 18000000 results should be
ignored. Instead of exploring these results then dropping them,
{{{PASSAGE}}} uses the index to retrieve the key at targeted offset,
and starts the range query there.
#+BEGIN_right-comment
The time complexity to create these iterators for range queries is
logarithmic compared to the number of elements matching the pattern.
#+END_right-comment

By using such sub-queries as basis, {{{PASSAGE}}} is able to pause and
resume the query execution of more complex SPARQL queries. 

*** Adding Support

Our aim is to support many databases with minimal effort, without
modifying the data. To that end, one must implement the interface
[[https://github.com/passage-org/passage/blob/main/passage-commons/src/main/java/fr/gdd/passage/commons/interfaces/Backend.java][=Backend=]]. This interface requires three templates =<ID, VALUE, SKIP>=
since most data structures rely on identifiers =<ID>= for storing the
triples/quads but on their own =<VALUE>= to store their actual value
(often in a separated dictionary).

Then, backends must provide a range query search that instantiate an
iterator:
#+BEGIN_SRC java :exports code
  BackendIterator<ID, VALUE, SKIP> search(final ID s, final ID p, final ID o);
#+END_SRC

Among other, the iterators must provide a skipping mechanism:
#+BEGIN_SRC java :exports code
  void skip(final SKIP to);
#+END_SRC



** SPARQL Operators

For a start, we focused on a subset of SPARQL operators: core SPARQL
[[core-sparql][[3]]]. It comprises triple patterns, basic graph
patterns, joins, unions, filters, and optionals.

*** TODO a table of supported operators with associated passage's version

But the principle of continuation queries goes beyond these
operators. For instance, we already know that a subset of aggregation
queries allow continuation…

*** TODO example of a continuation query using aggregates.


** Smart Clients

{{{PASSAGE}}} solely relies on the SPARQL standard to pause and resume
a query execution until completion. When a SPARQL continuation query
is sent back by the SPARQL endpoint, the requester is in charge of
returning it back to the endpoint, to get complete results.

*** TODO example using ~curl~.

It remains tedious… Instead, we [[https://github.com/passage-org/passage-comunica][added an actor]] to the smart client
[[https://comunica.dev/][Comunica]]. With a few lines of code, this web client is able to
decompose the query to run locally the operators that the remote
endpoint cannot handle.

*** TODO example of decomposed plan.

Contributions in this area are twofolds:

+ Keep the smart client up-to-date with Comunica. /For instance, the
  current implementation sets the subset of operations handled by
  {{{PASSAGE}}}. Instead, the server should advertise it./


+ Implement the same logic in other smart client. /While Comunica
  provides a convenient browser experience, it lacks some
  multithreading capabilities. Other engines such as [[https://github.com/LiUSemWeb/HeFQUIN][HeFQUIN]] could
  fill this gap./




* References

**** TODO [1] /Thi Hoang Thi Pham, Gabriela Montoya, Brice Nédelec, Hala Skaf-Molli, and Pascal Molli/. _PASSAGE: Ensuring Completeness and Responsiveness of Public SPARQL Endpoints with SPARQL Continuation Queries_. 2025.
<<passage>>

**** [2] /Thomas Minier, Hala Skaf-Molli, and Pascal Molli/. [[https://dl.acm.org/doi/10.1145/3308558.3313652][SaGe: Web Preemption for Public SPARQL Query Services]]. 2019.
<<sage>>

**** [3] /Jorge Pérez, Marcelo Arenas, and Claudio Gutiérrez/. [[https://dl.acm.org/doi/10.1145/1567274.1567278][Semantics and complexity of SPARQL]]. 2009.
<<core-sparql>>

**** [4] /Ruben Taelman, Joachim Van Herwegen, Miel Vander Sande, and Ruben Verborgh/. [[https://dl.acm.org/doi/10.1007/978-3-030-00668-6_15][Comunica: A Modular SPARQL Query Engine for the Web]]. 2018.
<<comunica>>
